---
title: "DeepSeek-V3技术报告解读"
date: 2025-01-28
permalink: /posts/2025/01/blog-post-7/
tags:
- deepseek
- LLM
---


paper地址：[DeepSeek_V3.pdf](https://github.com/deepseek-ai/DeepSeek-V3/blob/main/DeepSeek_V3.pdf)

我们推出DeepSeek-V3，这是一款强大的专家混合（MoE）语言模型，总参数达6710亿，每个词元激活370亿参数。为实现高效推理和经济高效的训练，DeepSeek-V3采用了多头潜在注意力（MLA）和DeepSeekMoE架构，这些在DeepSeek-V2中已得到充分验证。此外，DeepSeek-V3首创了无辅助损失的负载均衡策略，并设定了多词元预测训练目标以提升性能。我们在1.48万亿丰富多样且高质量的词元上对DeepSeek-V3进行预训练，随后经过监督微调与强化学习阶段，充分发挥其能力。全面评估显示，DeepSeek-V3性能超越其他开源模型，与领先的闭源模型相当。尽管性能卓越，DeepSeek-V3完成全部训练仅需278.8万个H800 GPU小时。此外，其训练过程极为稳定。在整个训练过程中，未出现任何无法恢复的损失激增情况，也无需进行任何回滚操作。模型检查点可在https://github.com/deepseek-ai/DeepSeek-V3获取。 

![](https://borninfreedom.github.io/images/2025/01/ds/1.png)

![](https://borninfreedom.github.io/images/2025/01/ds/content1.png)

![](https://borninfreedom.github.io/images/2025/01/ds/content2.png)

![](https://borninfreedom.github.io/images/2025/01/ds/content3.png)

# 1. 引言
近年来，大语言模型（LLMs）经历了快速的迭代与演进（Anthropic，2024；Google，2024；OpenAI，2024a），与通用人工智能（AGI）的差距逐渐缩小。除了闭源模型，开源模型，如DeepSeek系列（DeepSeek - AI，2024a，b，c；Guo等人，2024）、LLaMA系列（AI@Meta，2024a，b；Touvron等人，2023a，b）、Qwen系列（Qwen，2023，2024a，b）以及Mistral系列（Jiang等人，2023；Mistral，2024）也在取得重大进展，努力缩小与闭源模型的差距。为了进一步拓展开源模型的能力边界，我们扩大了模型规模，推出了DeepSeek - V3，这是一个拥有6710亿参数的大型专家混合（MoE）模型，每个词元激活370亿参数。

我们以具有前瞻性的视角，始终追求强大的模型性能和经济的成本。因此，在架构方面，DeepSeek-V3仍然采用多头潜在注意力（MLA）（DeepSeek - AI，2024c）来实现高效推理，并采用DeepSeekMoE（Dai等人，2024）进行经济高效的训练。这两种架构在DeepSeek-V2（DeepSeek - AI，2024c）中已得到验证，证明了它们在实现高效训练和推理的同时，能够维持强大的模型性能。除了基本架构，我们还实施了另外两种策略来进一步提升模型能力。首先，DeepSeek-V3开创了一种无辅助损失的负载均衡策略（Wang等人，2024a），旨在将为促进负载均衡而对模型性能产生的不利影响降至最低。其次，DeepSeek-V3采用了多词元预测训练目标，我们观察到这能提升模型在评估基准上的整体性能。

为了实现高效训练，我们支持FP8混合精度训练，并对训练框架进行了全面优化。低精度训练已成为实现高效训练的一种有前景的解决方案（Dettmers等人，2022；Kalamkar等人，2019；Narang等人，2017；Peng等人，2023b），其发展与硬件能力的提升紧密相关（Luo等人，2024；Micikevicius等人，2022；Rouhani等人，2023a）。在这项工作中，我们引入了一个FP8混合精度训练框架，并首次在超大规模模型上验证了其有效性。通过支持FP8计算和存储，我们实现了训练加速和GPU内存使用的减少。至于训练框架，我们设计了DualPipe算法用于高效的流水线并行，该算法的流水线气泡更少，并通过计算 - 通信重叠在训练过程中隐藏了大部分通信开销。这种重叠确保了随着模型规模进一步扩大，只要我们保持计算与通信的比例恒定，就仍然可以在节点间采用细粒度的专家并行，同时实现近乎零的全对全通信开销。此外，我们还开发了高效的跨节点全对全通信内核，以充分利用InfiniBand（IB）和NVLink带宽。再者，我们精心优化了内存占用，使得在不使用昂贵的张量并行的情况下也能够训练DeepSeek-V3。综合这些努力，我们实现了高训练效率。

在预训练阶段，我们使用1.48万亿高质量且多样的词元对DeepSeek-V3进行训练。预训练过程非常稳定。在整个训练过程中，我们没有遇到任何不可恢复的损失激增情况，也无需回滚。接下来，我们对DeepSeek - V3进行了两阶段的上下文长度扩展。第一阶段，最大上下文长度扩展到32K，第二阶段进一步扩展到128K。之后，我们对DeepSeek - V3的基础模型进行了训练后处理，包括监督微调（SFT）和强化学习（RL），使其符合人类偏好并进一步释放其潜力。在训练后处理阶段，我们从DeepSeek - R1系列模型中提炼推理能力，同时仔细维持模型准确性和生成长度之间的平衡。

我们在一系列全面的基准测试中对DeepSeek - V3进行评估。尽管训练成本经济，但综合评估显示，DeepSeek - V3 - Base已成为目前最强的开源基础模型，尤其是在代码和数学方面。其聊天版本在一系列标准和开放式基准测试中也超越了其他开源模型，性能与领先的闭源模型（包括GPT-4o和Claude-3.5-Sonnet）相当。

最后，我们再次强调DeepSeek - V3经济的训练成本，总结在表1中，这是通过我们对算法、框架和硬件的优化协同设计实现的。在预训练阶段，使用每一万亿词元训练DeepSeek - V3仅需18万个H800 GPU小时，即在拥有2048个H800 GPU的集群上训练3.7天。因此，我们的预训练阶段在不到两个月的时间内完成，耗费266.4万个GPU小时。加上上下文长度扩展的11.9万个GPU小时和训练后处理的0.5万个GPU小时，DeepSeek - V3完成全部训练仅需278.8万个GPU小时。假设H800 GPU的租用价格为每GPU小时2美元，我们的总训练成本仅为557.6万美元。请注意，上述成本仅包括DeepSeek - V3的正式训练，不包括与之前在架构、算法或数据方面的研究及消融实验相关的成本。

我们的主要贡献包括：
 - **架构**：创新的负载均衡策略和训练目标
    - 在DeepSeek - V2的高效架构基础上，我们开创了一种无辅助损失的负载均衡策略，将因促进负载均衡而导致的性能下降降至最低。
    - 我们研究了多词元预测（MTP）目标，并证明其对模型性能有益。它还可用于推测解码以加速推理。
 - **预训练**：追求极致训练效率
    - 我们设计了一个FP8混合精度训练框架，并首次在超大规模模型上验证了FP8训练的可行性和有效性。
    - 通过算法、框架和硬件的协同设计，我们克服了跨节点MoE训练中的通信瓶颈，实现了近乎完全的计算-通信重叠。这显著提高了我们的训练效率并降低了训练成本，使我们能够在不增加额外开销的情况下进一步扩大模型规模。
    - 仅以266.4万个H800 GPU小时的经济成本，我们就完成了在1.48万亿词元上对DeepSeek - V3的预训练，打造出目前最强的开源基础模型。预训练之后的后续训练阶段仅需10万个GPU小时。
 - **训练后处理**：从DeepSeek - R1中进行知识提炼
    - 我们引入了一种创新方法，将长思维链（CoT）模型（特别是DeepSeek R1系列模型之一）的推理能力提炼到标准大语言模型中，尤其是DeepSeek - V3。我们的流程巧妙地将R1的验证和反思模式融入DeepSeek - V3，显著提升了其推理性能。同时，我们也对DeepSeek - V3的输出风格和长度保持了控制。
 - **核心评估结果总结**
    - **知识**：（1）在MMLU、MMLU-Pro和GPQA等教育基准测试中，DeepSeek - V3超越了所有其他开源模型，在MMLU上得分为88.5，在MMLU - Pro上为75.9，在GPQA上为59.1。其性能与GPT - 4o和Claude - Sonnet - 3.5等领先的闭源模型相当，缩小了开源模型与闭源模型在该领域的差距。（2）在事实性基准测试中，DeepSeek - V3在SimpleQA和中文SimpleQA上的开源模型中表现出色。虽然在英语事实知识（SimpleQA）方面落后于GPT - 4o和Claude - Sonnet - 3.5，但在中文事实知识（中文SimpleQA）方面超越了这些模型，凸显了其在中文事实知识方面的优势。
    - **代码、数学和推理**：（1）在所有非长思维链的开源和闭源模型中，DeepSeek - V3在数学相关基准测试中取得了最先进的性能。值得注意的是，在特定基准测试（如MATH - 500）上，它甚至超越了o1 - preview，展示了其强大的数学推理能力。（2）在编码相关任务中，DeepSeek - V3在LiveCodeBench等编码竞赛基准测试中成为表现最佳的模型，巩固了其在该领域的领先地位。对于工程相关任务，虽然DeepSeek - V3的表现略低于Claude - Sonnet - 3.5，但仍大幅领先其他所有模型，展示了其在各种技术基准测试中的竞争力。

在本文的其余部分，我们首先详细阐述DeepSeek - V3的模型架构（第2节）。随后，我们介绍我们的基础设施，包括计算集群、训练框架、对FP8训练的支持、推理部署策略以及对未来硬件设计的建议。接下来，我们描述预训练过程，包括训练数据的构建、超参数设置、长上下文扩展技术、相关评估以及一些讨论（第4节）。之后，我们讨论训练后处理的工作，包括监督微调（SFT）、强化学习（RL）、相应的评估和讨论（第5节）。最后，我们总结这项工作，讨论DeepSeek - V3的现有局限性，并提出未来研究的潜在方向（第6节）。 

![](https://borninfreedom.github.io/images/2025/01/ds/t1.png)

![](https://borninfreedom.github.io/images/2025/01/ds/2.png)

# 2. 架构
我们首先介绍DeepSeek - V3的基本架构，其特点是采用多头潜在注意力（MLA）（DeepSeek - AI，2024c）实现高效推理，采用DeepSeekMoE（Dai等人，2024）实现经济高效的训练。然后，我们介绍一种多词元预测（MTP）训练目标，我们观察到该目标能提升模型在评估基准上的整体性能。对于其他未明确提及的细节，DeepSeek - V3遵循DeepSeek - V2（DeepSeek - AI，2024c）的设置。
## 2.1. 基本架构
DeepSeek - V3的基本架构仍基于Transformer（Vaswani等人，2017）框架。为实现高效推理和经济高效的训练，DeepSeek - V3同样采用了经DeepSeek - V2充分验证的MLA和DeepSeekMoE。与DeepSeek - V2相比，不同之处在于我们为DeepSeekMoE额外引入了一种无辅助损失的负载均衡策略（Wang等人，2024a），以减轻为确保负载均衡而导致的性能下降。图2展示了DeepSeek - V3的基本架构，在本节中我们将简要回顾MLA和DeepSeekMoE的细节。 

### 2.1.1. 多头潜在注意力
在注意力机制方面，DeepSeek - V3采用了MLA架构。设$d$表示嵌入维度，$n_h$表示注意力头的数量，$d_h$表示每个头的维度，并且$h_t \in \mathbb{R}^d$表示在给定注意力层中第$t$个词元的注意力输入。MLA的核心是对注意力键值进行低秩联合压缩，以在推理过程中减少键值（KV）缓存： 

![](https://borninfreedom.github.io/images/2025/01/ds/m1.png)
![](https://borninfreedom.github.io/images/2025/01/ds/tmp1.png)

![](https://borninfreedom.github.io/images/2025/01/ds/m2.png)


---

![](https://borninfreedom.github.io/images/2025/01/ds/tmp2.png)
![](https://borninfreedom.github.io/images/2025/01/ds/tmp3.png)
![](https://borninfreedom.github.io/images/2025/01/ds/tmp4.png)

---

### 2.1.2. 采用无辅助损失负载均衡的DeepSeekMoE
**DeepSeekMoE的基本架构**。对于前馈网络（FFN），DeepSeek - V3采用了DeepSeekMoE架构（Dai等人，2024）。与GShard（Lepikhin等人，2021）等传统的专家混合（MoE）架构相比，DeepSeekMoE使用了更细粒度的专家，并将部分专家独立出来作为共享专家。设u_t表示第t个词元的前馈网络输入，我们按如下方式计算前馈网络的输出h'_t： 

![](https://borninfreedom.github.io/images/2025/01/ds/m3.png)
![](https://borninfreedom.github.io/images/2025/01/ds/content4.png)


**无辅助损失的负载均衡**。对于专家混合（MoE）模型，专家负载不均衡会导致路由崩溃（Shazeer等人，2017），并在专家并行的场景中降低计算效率。传统解决方案通常依赖辅助损失（Fedus等人，2021；Lepikhin等人，2021）来避免负载不均衡。然而，过大的辅助损失会损害模型性能（Wang等人，2024a）。为了在负载均衡和模型性能之间实现更好的权衡，我们开创了一种无辅助损失的负载均衡策略（Wang等人，2024a）以确保负载均衡。具体来说，我们为每个专家引入一个偏差项$b_i$，并将其添加到相应的亲和度分数$s_{i,t}$中，以确定前$K$路由： 
![](https://borninfreedom.github.io/images/2025/01/ds/m4.png)


请注意，偏差项仅用于路由。而与前馈网络（FFN）输出相乘的门控值，仍由原始亲和度分数\(s_{i,t}\)得出。在训练过程中，我们持续监控每个训练步骤中整批数据的专家负载情况。在每一步结束时，如果某个专家负载过重，我们会将其对应的偏差项减小\(\gamma\)；如果负载过轻，则将其对应的偏差项增加\(\gamma\)，其中\(\gamma\)是一个名为偏差更新速度的超参数。通过这种动态调整，DeepSeek - V3在训练期间保持专家负载平衡，并且比那些仅通过纯辅助损失来促进负载平衡的模型性能更好。

尽管DeepSeek - V3主要依靠无辅助损失策略来实现负载平衡，但为防止任何单个序列内出现极端不平衡，我们还采用了一种互补的序列级平衡损失：
![](https://borninfreedom.github.io/images/2025/01/ds/m5.png)

其中，平衡因子\(\alpha\)是一个超参数，对于DeepSeek - V3，它会被赋予一个极小的值；\(1(·)\)表示指示函数；\(T\)表示一个序列中的词元数量。这种基于序列的平衡损失有助于促使每个序列上的专家负载达到均衡。 


![](https://borninfreedom.github.io/images/2025/01/ds/3.png)
图3 | 我们的多词元预测（MTP）实现示意图。在每个深度，我们保留预测每个词元的完整因果链。 


**节点受限路由**。与DeepSeek - V2所采用的设备受限路由类似，DeepSeek - V3同样运用了一种受限路由机制，以在训练过程中控制通信成本。简而言之，我们确保每个词元最多被发送至M个节点，这些节点是依据分布在每个节点上的专家的最高 \(K_rM\) 亲和度分数之和来选定的。在这一限制条件下，我们的专家混合（MoE）训练框架几乎能够实现计算与通信的完全重叠。

**无词元丢弃**。由于采用了有效的负载均衡策略，DeepSeek - V3在整个训练过程中都能保持良好的负载均衡状态。因此，DeepSeek - V3在训练期间不会丢弃任何词元。此外，我们还实施了特定的部署策略，以确保推理时的负载均衡，所以DeepSeek - V3在推理过程中也不会丢弃词元。

## 2.2 多词元预测
受Gloeckle等人（2024年）的启发，我们为DeepSeek - V3研究并设定了多词元预测（MTP）目标，该目标将每个位置的预测范围拓展至多个未来词元。一方面，MTP目标强化了训练信号，可能会提升数据效率。另一方面，MTP或许能让模型预先规划其表征，以便更好地预测未来词元。图3展示了我们MTP的实现方式。与Gloeckle等人（2024年）通过独立输出头并行预测D个额外词元不同，我们按顺序预测额外词元，并在每个预测深度保留完整的因果链。我们将在本节介绍MTP实现的详细内容。

![](https://borninfreedom.github.io/images/2025/01/ds/tmp5.png)


#### MTP训练目标
对于每个预测深度，我们计算一个交叉熵损失 \(L_{MTP}^{k}\)：

![](https://borninfreedom.github.io/images/2025/01/ds/m6.png)
![](https://borninfreedom.github.io/images/2025/01/ds/tmp6.png)


#### MTP在推理中的应用
我们的MTP策略主要旨在提升主模型的性能，因此在推理过程中，我们可以直接舍弃MTP模块，主模型能够独立且正常地运行。此外，我们也可以将这些MTP模块重新用于推测解码，以进一步降低生成延迟。 



![](https://borninfreedom.github.io/images/2025/01/ds/4.png)
图4 | 一对单独的正向和反向块的重叠策略（Transformer模块的边界未对齐）。橙色表示正向，绿色表示“输入反向”，蓝色表示“权重反向”，紫色表示流水线并行（PP）通信，红色表示屏障。全对全通信和PP通信都可以被完全隐藏。 

![](https://borninfreedom.github.io/images/2025/01/ds/5.png)
图5 | 8个流水线并行（PP）等级和20个微批次在两个方向上的DualPipe调度示例。
反向的微批次与正向的微批次对称，为简化图示，我们省略了反向微批次的批次ID。由共享黑色边框包围的两个单元格具有相互重叠的计算和通信。 

# 3. 基础设施
## 3.1 计算集群
DeepSeek - V3在一个配备2048块NVIDIA H800 GPU的集群上进行训练。H800集群中的每个节点包含8块通过NVLink和NVSwitch在节点内部连接的GPU。在不同节点之间，使用InfiniBand（IB）互连来实现通信。
## 3.2 训练框架
DeepSeek - V3的训练由HAI-LLM框架支持，这是一个由我们的工程师全新打造的高效轻量级训练框架。总体而言，DeepSeek-V3采用16路流水线并行（PP）（Qi等人，2023a）、跨8个节点的64路专家并行（EP）（Lepikhin等人，2021）以及ZeRO-1数据并行（DP）（Rajbhandari等人，2020）。

为了促进DeepSeek - V3的高效训练，我们进行了细致的工程优化。首先，我们设计了DualPipe算法以实现高效的流水线并行。与现有的PP方法相比，DualPipe的流水线气泡更少。更重要的是，它在正向和反向过程中实现了计算和通信阶段的重叠，从而解决了跨节点专家并行带来的高通信开销问题。其次，我们开发了高效的跨节点全对全通信内核，以充分利用IB和NVLink带宽，并节省专门用于通信的流多处理器（SM）。最后，我们精心优化了训练过程中的内存占用，从而能够在不使用昂贵的张量并行（TP）的情况下训练DeepSeek - V3。
### 3.2.1 DualPipe与计算 - 通信重叠
对于DeepSeek - V3，跨节点专家并行带来的通信开销导致计算与通信的比率约为1:1，效率较低。为应对这一挑战，我们设计了一种创新的流水线并行算法DualPipe，它不仅通过有效重叠正向和反向的计算 - 通信阶段来加速模型训练，还减少了流水线气泡。

DualPipe的关键思想是在一对单独的正向和反向块内实现计算和通信的重叠。具体来说，我们将每个块分为四个部分：注意力、all-to-all分发、多层感知器（MLP）和all-to-all合并。特别地，对于反向块，注意力和MLP都像在ZeroBubble（Qi等人，2023b）中那样，进一步分为输入反向和权重反向两部分。此外，我们还有一个PP通信组件。如图4所示，对于一对正向和反向块，我们重新排列这些组件，并手动调整专门用于通信与计算的GPU SM的比例。在这种重叠策略下，我们可以确保在执行过程中全对全通信和PP通信都能被完全隐藏。鉴于这种高效的重叠策略，完整的DualPipe调度如图5所示。它采用双向流水线调度，从流水线的两端同时输入微批次数据，并且大部分通信可以完全重叠。这种重叠还确保了随着模型进一步扩展，只要我们保持恒定的计算与通信比率，就仍然可以在节点间采用细粒度的专家并行，同时实现近乎零的全对全通信开销。

此外，即使在通信负担不重的更一般场景中，DualPipe仍然具有效率优势。在表2中，我们总结了不同PP方法的流水线气泡和内存使用情况。如表所示，与ZB1P（Qi等人，2023b）和1F1B（Harlap等人，2018）相比，DualPipe显著减少了流水线气泡，同时峰值激活内存仅增加1/PP倍。尽管DualPipe需要保留两份模型参数，但由于我们在训练期间使用较大的EP规模，这并不会显著增加内存消耗。与Chimera（Li和Hoefler，2021）相比，DualPipe只要求流水线阶段和微批次能被2整除，而不要求微批次能被流水线阶段整除。此外，对于DualPipe，随着微批次数量的增加，气泡和激活内存都不会增加。
### 3.2.2 跨节点全对全通信的高效实现
为了确保DualPipe有足够的计算性能，我们定制了高效的跨节点全对全通信内核（包括分发和合并），以节省专门用于通信的SM数量。内核的实现与MoE门控算法和我们集群的网络拓扑共同设计。具体来说，在我们的集群中，跨节点GPU通过IB完全互连，节点内通信通过NVLink处理。NVLink提供160GB/s的带宽，大约是IB（50GB/s）的3.2倍。为了有效利用IB和NVLink的不同带宽，我们将每个词元最多分发到4个节点，从而减少IB流量。对于每个词元，当做出路由决策时，它将首先通过IB传输到目标节点上具有相同节点内索引的GPU。一旦到达目标节点，我们将努力确保它能通过NVLink立即转发到承载目标专家的特定GPU，而不会被随后到达的词元阻塞。通过这种方式，通过IB和NVLink的通信完全重叠，并且每个词元在每个节点上可以高效地平均选择3.2个专家，而不会产生来自NVLink的额外开销。这意味着，尽管DeepSeek - V3在实际中只选择8个路由专家，但它可以在保持相同通信成本的情况下，将这个数字最多扩展到13个专家（4个节点×3.2个专家/节点）。总体而言，在这样的通信策略下，仅需20个SM就足以充分利用IB和NVLink的带宽。

详细来说，我们采用了线程束专用化技术（Bauer等人，2014），并将20个SM划分为10个通信通道。在分发过程中，（1）IB发送、（2）IB到NVLink的转发以及（3）NVLink接收分别由各自的线程束处理。分配给每个通信任务的线程束数量根据所有SM上的实际工作量动态调整。类似地，在合并过程中，（1）NVLink发送、（2）NVLink到IB的转发和累加以及（3）IB接收和累加也由动态调整的线程束处理。此外，分发和合并内核都与计算流重叠，因此我们也考虑了它们对其他SM计算内核的影响。具体来说，我们采用定制的PTX（并行线程执行）指令，并自动调整通信块大小，这显著减少了L2缓存的使用以及对其他SM的干扰。
### 3.2.3 以最小开销实现极致内存节省
为了减少训练过程中的内存占用，我们采用了以下技术。
 - **RMSNorm和MLA上投影的重计算**：我们在反向传播过程中重新计算所有RMSNorm操作和MLA上投影，从而无需持续存储它们的输出激活。通过少量的开销，这种策略显著降低了存储激活所需的内存。
 - **CPU中的指数移动平均**：在训练过程中，我们保留模型参数的指数移动平均（EMA），以便在学习率衰减后对模型性能进行早期估计。EMA参数存储在CPU内存中，并在每个训练步骤后异步更新。这种方法使我们能够维护EMA参数，而不会产生额外的内存或时间开销。
 - **多词元预测的共享嵌入和输出头**：通过DualPipe策略，我们将模型的最浅层（包括嵌入层）和最深层（包括输出头）部署在相同的PP等级上。这种安排使得MTP模块和主模型之间可以在物理上共享共享嵌入和输出头的参数和梯度。这种物理共享机制进一步提高了我们的内存效率。
## 3.3 FP8训练
受近期低精度训练进展（Dettmers等人，2022；Noune等人，2022；Peng等人，2023b）的启发，我们提出了一种利用FP8数据格式训练DeepSeek - V3的细粒度混合精度框架。虽然低精度训练前景广阔，但它常常受到激活、权重和梯度中异常值的限制（Fishman等人，2024；He等人；Sun等人，2024）。尽管在推理量化方面已经取得了显著进展（Frantar等人，2022；Xiao等人，2023），但相对较少有研究表明低精度技术在大规模语言模型预训练中的成功应用（Fishman等人，2024）。为了应对这一挑战并有效扩展FP8格式的动态范围，我们引入了一种细粒度量化策略：采用1×N_c元素的分块分组或N_c×N_c元素的块级分组。在我们提高精度的累加过程中，相关的反量化开销在很大程度上得到缓解，这是实现准确的FP8通用矩阵乘法（GEMM）的关键方面。此外，为了进一步减少MoE训练中的内存和通信开销，我们以FP8缓存和分发激活，同时以BF16存储低精度优化器状态。我们在两个与DeepSeek - V2 - Lite和DeepSeek - V2规模相似的模型上验证了所提出的FP8混合精度框架，训练约1万亿词元（详见附录B.1）。值得注意的是，与BF16基线相比，我们的FP8训练模型的相对损失误差始终保持在0.25%以下，这一水平完全在训练随机性的可接受范围内。
![](https://borninfreedom.github.io/images/2025/01/ds/6.png)

### 3.3.1 混合精度框架
基于低精度训练中广泛采用的技术（Kalamkar等人，2019；Narang等人，2017），我们提出了一种用于FP8训练的混合精度框架。在这个框架中，大多数计算密集型操作以FP8进行，而一些关键操作则策略性地保持其原始数据格式，以平衡训练效率和数值稳定性。整体框架如图6所示。

首先，为了加速模型训练，大多数核心计算内核，即GEMM操作，以FP8精度实现。这些GEMM操作接受FP8张量作为输入，并以BF16或FP32输出。如图6所示，与线性算子相关的所有三个GEMM操作，即前向传播（Fprop）、激活反向传播（Dgrad）和权重反向传播（Wgrad），都以FP8执行。这种设计理论上使计算速度比原始的BF16方法提高了一倍。此外，FP8的Wgrad GEMM允许以FP8存储激活，以便在反向传播中使用。这显著降低了内存消耗。

尽管FP8格式具有效率优势，但某些算子由于对低精度计算敏感，仍然需要更高的精度。此外，一些低成本算子也可以使用更高的精度，而对整体训练成本的影响可忽略不计。因此，经过仔细研究，我们对以下组件保持原始精度（例如BF16或FP32）：嵌入模块、输出头、MoE门控模块、归一化算子和注意力算子。这些有针对性的高精度保留确保了DeepSeek - V3训练动态的稳定性。为了进一步保证数值稳定性，我们以更高的精度存储主权重、权重梯度和优化器状态。虽然这些高精度组件会产生一些内存开销，但通过在我们的分布式训练系统中跨多个DP等级进行高效分片，其影响可以降至最低。 
![](https://borninfreedom.github.io/images/2025/01/ds/7.png)
图7 | （a）我们提出一种细粒度量化方法，以减轻由特征异常值导致的量化误差；为简化说明，仅展示了前向传播（Fprop）。（b）结合我们的量化策略，我们通过每隔 \(N_C = 128\) 个元素提升至CUDA核心进行高精度累加的矩阵乘法运算（MMA），来提高FP8通用矩阵乘法（GEMM）的精度。 

### 3.3.2. 通过量化和乘法提高精度
基于我们的FP8混合精度框架，我们引入了几种策略来提高低精度训练的准确性，重点关注量化方法和乘法过程。
#### 细粒度量化
在低精度训练框架中，由于FP8格式的动态范围有限（受其指数位减少的限制），溢出和下溢是常见的挑战。按照标准做法，通过将输入张量的最大绝对值缩放到FP8的最大可表示值，使输入分布与FP8格式的可表示范围对齐（Narang等人，2017）。这种方法使低精度训练对激活异常值高度敏感，而异常值会严重降低量化精度。为了解决这个问题，我们提出了一种细粒度量化方法，在更细的粒度级别上进行缩放。如图7 (a)所示，（1）对于激活值，我们以1x128的块为基础对元素进行分组和缩放（即每个词元每128个通道）；（2）对于权重，我们以128x128的块为基础对元素进行分组和缩放（即每128个输入通道对应每128个输出通道）。这种方法通过根据更小的元素组调整缩放比例，确保量化过程能够更好地适应异常值。在附录B.2中，我们进一步讨论了在对激活值像对权重量化那样以块为基础进行分组和缩放时出现的训练不稳定性问题。

我们方法中的一个关键改进是在GEMM运算的内维度上引入了每组缩放因子。标准的FP8 GEMM并不直接支持这一功能。然而，结合我们精确的FP32累加策略，它可以得到高效实现。

值得注意的是，我们的细粒度量化策略与微缩放格式的理念高度一致（Rouhani等人，2023b），而英伟达下一代GPU（Blackwell系列）的张量核心已经宣布支持具有更小量化粒度的微缩放格式（NVIDIA，2024a）。我们希望我们的设计能为未来的工作提供参考，以跟上最新的GPU架构发展。
#### 提高累加精度
低精度GEMM运算经常会遇到下溢问题，其准确性在很大程度上依赖于高精度累加，通常采用FP32精度进行累加（Kalamkar等人，2019；Narang等人，2017）。然而，我们观察到，英伟达H800 GPU上FP8 GEMM的累加精度仅限于保留约14位，这明显低于FP32累加精度。当内维度K较大时，这个问题会更加明显（Wortsman等人，2023），而在大规模模型训练中，增大批量大小和模型宽度是常见的场景。以两个随机矩阵的GEMM运算（K = 4096）为例，在我们的初步测试中，张量核心有限的累加精度导致最大相对误差接近2%。尽管存在这些问题，有限的累加精度在一些FP8框架中仍然是默认选项（NVIDIA，2024b），这严重限制了训练的准确性。

为了解决这个问题，我们采用了提升到CUDA核心以获得更高精度的策略（Thakkar等人，2023）。这个过程如图7 (b)所示。具体来说，在张量核心执行矩阵乘法累加（MMA）时，中间结果使用有限的位宽进行累加。一旦达到\(N_C\)的间隔，这些部分结果将被复制到CUDA核心的FP32寄存器中，在那里进行全精度的FP32累加。如前所述，我们的细粒度量化沿内维度K应用每组缩放因子。这些缩放因子可以在CUDA核心上作为反量化过程进行高效乘法运算，额外的计算成本极小。

值得注意的是，这种修改会降低单个线程组的WGMMA（线程组级矩阵乘法累加）指令执行速率。然而，在H800架构中，通常会同时有两个WGMMA持续执行：当一个线程组执行提升操作时，另一个可以执行MMA操作。这种设计使这两个操作能够重叠，保持张量核心的高利用率。根据我们的实验，将\(N_C\)设置为128个元素（相当于4个WGMMAs）是既能显著提高精度又不会引入大量开销的最小累加间隔。
#### 尾数优先于指数
与先前工作采用的混合FP8格式（NVIDIA，2024b；Peng等人，2023b；Sun等人，2019b）不同，后者在前向传播（Fprop）中使用E4M3（4位指数和3位尾数），在激活反向传播（Dgrad）和权重反向传播（Wgrad）中使用E5M2（5位指数和2位尾数），我们在所有张量上采用E4M3格式以获得更高的精度。我们认为这种方法的可行性得益于我们的细粒度量化策略，即按块和按块组进行缩放。通过对较小的元素组进行操作，我们的方法有效地在这些分组元素之间共享指数位，减轻了有限动态范围的影响。
#### 在线量化
张量级量化框架（NVIDIA，2024b；Peng等人，2023b）采用延迟量化，它会保留先前迭代中最大绝对值的历史记录，以推断当前值。为了确保缩放比例准确并简化框架，我们为每个1x128的激活块或128x128的权重块在线计算最大绝对值。基于此，我们推导出缩放因子，然后将激活值或权重在线量化为FP8格式。
### 3.3.3. 低精度存储和通信
结合我们的FP8训练框架，我们通过将缓存的激活值和优化器状态压缩为更低精度的格式，进一步降低了内存消耗和通信开销。
#### 低精度优化器状态
我们采用BF16数据格式而不是FP32来跟踪AdamW优化器（Loshchilov和Hutter，2017）中的一阶和二阶矩，而不会导致明显的性能下降。然而，主权重（由优化器存储）和梯度（用于批量大小累加）仍然保留为FP32，以确保训练过程中的数值稳定性。
#### 低精度激活
如图6所示，Wgrad操作以FP8执行。为了减少内存消耗，自然的选择是以FP8格式缓存激活值，用于线性算子的反向传播。然而，对于几个算子，我们进行了特殊考虑，以实现低成本的高精度训练：
 - **注意力算子之后线性层的输入**：这些激活值也用于注意力算子的反向传播，因此对精度很敏感。我们专门为这些激活值采用了定制的E5M6数据格式。此外，在反向传播中，这些激活值将从1x128的量化块转换为128x1的块。为了避免引入额外的量化误差，所有的缩放因子都进行了舍入缩放，即2的整数次幂。
 - **MoE中SwiGLU算子的输入**：为了进一步降低内存成本，我们缓存SwiGLU算子的输入，并在反向传播中重新计算其输出。这些激活值也使用我们的细粒度量化方法以FP8存储，在内存效率和计算准确性之间取得平衡。
#### 低精度通信
通信带宽是MoE模型训练中的一个关键瓶颈。为了缓解这一挑战，我们在MoE上投影之前将激活值量化为FP8，然后应用分发组件，这与MoE上投影中的FP8前向传播兼容。与注意力算子之后线性层的输入一样，该激活值的缩放因子也是2的整数次幂。类似的策略也应用于MoE下投影之前的激活梯度。对于前向和反向合并组件，我们将它们保留为BF16，以在训练流程的关键部分保持训练精度。
## 3.4. 推理和部署
我们将DeepSeek - V3部署在H800集群上，集群中每个节点内的GPU通过NVLink互连，整个集群中的所有GPU通过IB完全互连。为了同时确保在线服务的服务级别目标（SLO）和高吞吐量，我们采用了以下将预填充和解码阶段分开的部署策略。
### 3.4.1. 预填充
预填充阶段的最小部署单元由4个节点和32个GPU组成。注意力部分采用4路张量并行（TP4）和序列并行（SP），并结合8路数据并行（DP8）。其较小的TP规模（4）限制了TP通信的开销。对于MoE部分，我们使用32路专家并行（EP32），这确保每个专家处理足够大的批量大小，从而提高计算效率。对于MoE的全对全通信，我们使用与训练中相同的方法：首先通过IB在节点间传输词元，然后通过NVLink在节点内的GPU之间转发。特别地，我们对浅层的密集MLP使用1路张量并行，以节省TP通信。

为了实现MoE部分不同专家之间的负载均衡，我们需要确保每个GPU处理的词元数量大致相同。为此，我们引入了冗余专家的部署策略，即复制高负载专家并进行冗余部署。高负载专家是根据在线部署期间收集的统计数据检测出来的，并定期（例如每10分钟）进行调整。确定冗余专家集合后，我们根据观察到的负载在节点内的GPU之间仔细重新安排专家，努力在不增加跨节点全对全通信开销的情况下尽可能平衡GPU之间的负载。对于DeepSeek - V3的部署，我们为预填充阶段设置了32个冗余专家。对于每个GPU，除了它原本托管的8个专家外，还将托管一个额外的冗余专家。

此外，在预填充阶段，为了提高吞吐量并隐藏全对全和TP通信的开销，我们同时处理两个计算工作量相似的微批次，将一个微批次的注意力和MoE操作与另一个微批次的分发和合并操作重叠。

最后，我们正在探索一种专家动态冗余策略，即每个GPU托管更多的专家（例如16个专家），但在每次推理步骤中只激活9个。在每层的全对全操作开始之前，我们动态计算全局最优路由方案。鉴于预填充阶段涉及大量计算，计算此路由方案的开销几乎可以忽略不计。
### 3.4.2. 解码
在解码过程中，我们将共享专家视为路由专家。从这个角度来看，每个词元在路由时将选择9个专家，其中共享专家被视为高负载专家，始终会被选中。解码阶段的最小部署单元由40个节点和320个GPU组成。注意力部分采用TP4和SP，并结合DP80，而MoE部分使用EP320。对于MoE部分，每个GPU只托管一个专家，64个GPU负责托管冗余专家和共享专家。分发和合并部分的全对全通信通过IB进行直接的点对点传输，以实现低延迟。此外，我们利用IBGDA技术（NVIDIA，2022）进一步降低延迟并提高通信效率。

与预填充阶段类似，我们根据在线服务中的专家负载统计数据，在一定间隔内定期确定冗余专家集合。然而，由于每个GPU只托管一个专家，我们不需要重新安排专家。我们也在探索解码阶段的动态冗余策略。不过，这需要更仔细地优化计算全局最优路由方案的算法，并将其与分发内核进行融合以降低开销。

此外，为了提高吞吐量并隐藏全对全通信的开销，我们也在探索在解码阶段同时处理两个计算工作量相似的微批次。与预填充阶段不同，解码阶段注意力消耗的时间占比更大。因此，我们将一个微批次的注意力操作与另一个微批次的分发 + MoE + 合并操作重叠。在解码阶段，每个专家的批量大小相对较小（通常在256个词元以内），瓶颈在于内存访问而非计算。由于MoE部分只需要加载一个专家的参数，内存访问开销极小，因此使用较少的SM不会显著影响整体性能。因此，为了避免影响注意力部分的计算速度，我们可以只分配一小部分SM用于分发 + MoE + 合并操作。
## 3.5. 硬件设计建议
基于我们对全对全通信和FP8训练方案的实现，我们向AI硬件供应商提出以下芯片设计建议。
### 3.5.1. 通信硬件
在DeepSeek - V3中，我们实现了计算和通信的重叠，以在计算过程中隐藏通信延迟。与串行的计算和通信方式相比，这显著降低了对通信带宽的依赖。然而，当前的通信实现依赖于昂贵的SM（例如，我们在H800 GPU可用的132个SM中分配了20个用于此目的），这会限制计算吞吐量。此外，使用SM进行通信会导致效率显著降低，因为张量核心完全未得到充分利用。

目前，SM在全对全通信中主要执行以下任务：
 - 在IB（InfiniBand）和NVLink域之间转发数据，同时将来自单个GPU、发往同一节点内多个GPU的IB流量进行聚合。
 - 在RDMA缓冲区（已注册的GPU内存区域）和输入/输出缓冲区之间传输数据。
 - 执行全对全合并的归约操作。
 - 在跨IB和NVLink域向多个专家传输分块数据时管理细粒度的内存布局。

我们希望未来的供应商开发能够将这些通信任务从宝贵的计算单元SM上卸载下来的硬件，作为GPU协处理器或像英伟达SHARP（Graham等人，2016）那样的网络协处理器。此外，为了降低应用程序编程的复杂性，我们希望这种硬件能够从计算单元的角度统一IB（横向扩展）和NVLink（纵向扩展）网络。有了这个统一的接口，计算单元可以通过基于简单原语提交通信请求，轻松完成跨整个IB - NVLink统一域的读、写、多播和归约等操作。
### 3.5.2. 计算硬件
#### 提高张量核心中FP8 GEMM的累加精度
在英伟达Hopper架构当前的张量核心实现中，FP8 GEMM（通用矩阵乘法）采用定点累加，在相加之前根据最大指数对尾数乘积进行右移对齐。我们的实验表明，在符号填充右移后，它只使用每个尾数乘积的最高14位，并截断超出此范围的位。然而，例如，要通过32次FP8×FP8乘法的累加得到精确的FP32结果，至少需要34位精度。因此，我们建议未来的芯片设计提高张量核心中的累加精度，以支持全精度累加，或者根据训练和推理算法的准确性要求选择合适的累加位宽。这种方法可以确保误差保持在可接受的范围内，同时保持计算效率。
#### 支持按块和按块组量化
当前的GPU仅支持按张量量化，缺乏对像我们的按块和按块组量化这样的细粒度量化的原生支持。在当前的实现中，当达到\(N_C\)间隔时，部分结果将从张量核心复制到CUDA核心，乘以缩放因子，然后添加到CUDA核心的FP32寄存器中。尽管结合我们精确的FP32累加策略，反量化开销得到了显著缓解，但张量核心和CUDA核心之间频繁的数据移动仍然限制了计算效率。因此，我们建议未来的芯片通过使张量核心能够接收缩放因子并实现带组缩放的MMA来支持细粒度量化。这样，整个部分和累加与反量化过程可以直接在张量核心内完成，直到产生最终结果，避免频繁的数据移动。
#### 支持在线量化
当前的实现难以有效支持在线量化，尽管我们的研究证明了其有效性。在现有过程中，我们需要从HBM（高带宽内存）读取128个BF16激活值（前一次计算的输出）进行量化，量化后的FP8值再写回HBM，之后又要再次读取用于MMA。为了解决这种低效问题，我们建议未来的芯片将FP8转换和TMA（张量内存加速器）访问集成到一个融合操作中，这样在激活值从全局内存传输到共享内存的过程中就可以完成量化，避免频繁的内存读写。我们还建议支持线程束级的转换指令以提高速度，这将进一步促进层归一化和FP8转换的更好融合。或者，可以采用近内存计算方法，将计算逻辑放置在HBM附近。在这种情况下，BF16元素从HBM读取到GPU时可以直接转换为FP8，将片外内存访问减少约50%。
#### 支持转置GEMM操作
当前的架构使得将矩阵转置与GEMM操作融合变得繁琐。在我们的工作流程中，前向传播期间的激活值被量化为1x128的FP8块并存储。在反向传播期间，矩阵需要被读出、反量化、转置、重新量化为128x1的块，然后存储在HBM中。为了减少内存操作，我们建议未来的芯片能够在MMA操作之前直接从共享内存中进行矩阵的转置读取，以满足训练和推理所需的精度。结合FP8格式转换和TMA访问的融合，这一改进将显著简化量化工作流程。 

![](https://borninfreedom.github.io/images/2025/01/ds/8.png)

---

“Needle In A Haystack”即“大海捞针”，是一种用于评估语言模型长文本处理性能的测试方法，以下是具体介绍：
- **测试目的**：主要用于评估语言模型在长上下文窗口中的性能，检验模型从大量文本中检索特定信息的能力，考量模型能否准确找到隐藏在长文本中的关键信息，反映其对长文本的理解、记忆和信息提取能力。
- **测试方法**
    - **构建文本**：将一个特定的事实、陈述或关键信息作为“针”，嵌入到一个长文本语境“草垛”中，长文本可以是各种类型的文档内容。
    - **提出问题**：针对嵌入的“针”设计问题，让语言模型基于给定的长文本进行回答，比如询问与“针”相关的内容或要求提取“针”所代表的信息。
    - **评估结果**：对比模型的回答与实际“针”的内容，判断模型是否正确检索到关键信息，计算准确率、召回率等指标，也可通过可视化等方式展示模型在不同位置、不同长度文本中的检索表现。
- **测试类型**
    - **单一信息检索任务**：评估语言模型在长文本中提取单一关键信息的能力，测试其对广泛叙述中特定细节的精确回忆能力。
    - **多信息检索任务**：探讨语言模型从长文本中检索多个相关信息的能力，模拟实际场景中对综合文档的复杂查询。
    - **多信息推理任务**：通过提取并利用长文本中的多个关键信息来评估语言模型的长文本能力，要求模型对各关键信息片段有综合理解。
    - **祖先追溯挑战**：通过设计“亲属关系针”，测试语言模型处理真实长文本中多层逻辑挑战的能力。

---

![](https://borninfreedom.github.io/images/2025/01/ds/t3.png)
表3 | DeepSeek - V3基础模型与其他有代表性的开源基础模型的对比。所有模型均在我们的内部框架中进行评估，且评估设置相同。差距不超过0.3的分数被视为处于同一水平。DeepSeek - V3基础模型在大多数基准测试中表现最佳，尤其是在数学和代码任务上。 

# 4. 预训练
## 4.1 数据构建
与DeepSeek - V2相比，我们优化了预训练语料库，提高了数学和编程样本的比例，同时将多语言覆盖范围扩展到英语和中文之外。此外，我们细化了数据处理流程，在保持语料库多样性的同时尽量减少冗余。受Ding等人（2024）的启发，我们采用文档打包方法以保证数据完整性，但在训练过程中不采用跨样本注意力掩码。最终，DeepSeek - V3的训练语料库在我们的分词器中有14.8T高质量且多样的词元。

在DeepSeekCoder - V2（DeepSeek - AI，2024a）的训练过程中，我们发现 “填中间”（Fill - in - Middle，FIM）策略在使模型能够根据上下文线索准确预测中间文本的同时，不会损害下一词元预测能力。与DeepSeekCoder - V2一致，我们在DeepSeek - V3的预训练中也采用了FIM策略。具体来说，我们采用前缀 - 后缀 - 中间（Prefix - Suffix - Middle，PSM）框架来构建数据，格式如下：
<|fim_begin|> 𝑓前缀<|fim_hole|> 𝑓后缀<|fim_end|> 𝑓中间<|eos_token|>

这种结构在文档层面作为预打包过程的一部分应用。FIM策略的应用比例为0.1，与PSM框架一致。

DeepSeek - V3的分词器采用字节级BPE（Shibata等人，1999），扩展后的词汇表有128K个词元。我们对分词器的预分词器和训练数据进行了修改，以优化多语言压缩效率。此外，与DeepSeek - V2相比，新的预分词器引入了结合标点和换行符的词元。然而，当模型处理没有末尾换行符的多行提示时，特别是在少样本评估提示中，这种方法可能会引入词元边界偏差（Lundberg，2023）。为了解决这个问题，我们在训练期间随机拆分一定比例的此类组合词元，使模型接触到更广泛的特殊情况，从而减轻这种偏差。
## 4.2 超参数
**模型超参数**：我们将Transformer层数设置为61，隐藏维度设置为7168。所有可学习参数均以0.006的标准差进行随机初始化。在MLA中，我们将注意力头的数量\(n_h\)设置为128，每个头的维度\(d_h\)设置为128。KV压缩维度\(d_c\)设置为512，查询压缩维度\(d'_c\)设置为1536。对于解耦的查询和键，我们将每个头的维度\(d^h_R\)设置为64。除了前三层，我们用MoE层替换所有前馈网络（FFN）。每个MoE层由1个共享专家和256个路由专家组成，每个专家的中间隐藏维度为2048。在路由专家中，每个词元将激活8个专家，并且每个词元最多被发送到4个节点。多词元预测深度\(D\)设置为1，即除了准确的下一个词元外，每个词元还将预测一个额外的词元。与DeepSeek - V2一样，DeepSeek - V3在压缩后的潜在向量之后也采用了额外的RMSNorm层，并在宽度瓶颈处乘以额外的缩放因子。在这种配置下，DeepSeek - V3总共有6710亿个参数，每个词元激活370亿个参数。

**训练超参数**：我们采用AdamW优化器（Loshchilov和Hutter，2017），超参数设置为\(\beta_1 = 0.9\)，\(\beta_2 = 0.95\)，权重衰减weight_decay = 0.1。预训练期间，我们将最大序列长度设置为4K，并在14.8T词元上对DeepSeek - V3进行预训练。关于学习率调度，在前2K步中，我们首先将其从0线性增加到2.2×10^{-4}。然后，在模型消耗10T训练词元之前，保持2.2×10^{-4}的恒定学习率。随后，在4.3T词元内，按照余弦退火曲线将学习率逐渐衰减到2.2×10^{-5}。在最后5000亿词元的训练中，前3330亿词元保持\(2.2×10^{-5}\)的恒定学习率，剩余1670亿词元切换到\(7.3×10^{-6}\)的恒定学习率。梯度裁剪范数设置为1.0。我们采用批量大小调度策略，在前4690亿词元的训练中，批量大小从3072逐渐增加到15360，在剩余训练中保持15360。我们利用流水线并行将模型的不同层部署在不同的GPU上，对于每一层，路由专家将均匀部署在属于8个节点的64个GPU上。对于节点受限路由，每个词元最多被发送到4个节点（即\(M = 4\)）。对于无辅助损失的负载均衡，在前14.3T词元的训练中，我们将偏差更新速度\(\gamma\)设置为0.001，在剩余5000亿词元的训练中设置为0.0。对于平衡损失，我们将\(\alpha\)设置为0.0001，只是为了避免任何单个序列内出现极端不平衡。MTP损失权重\(\lambda\)在前10T词元的训练中设置为0.3，在剩余4.8T词元的训练中设置为0.1。
### 4.3 长上下文扩展
我们采用与DeepSeek - V2（DeepSeek - AI，2024c）类似的方法，使DeepSeek - V3具备长上下文处理能力。在预训练阶段之后，我们应用YaRN（Peng等人，2023a）进行上下文扩展，并执行两个额外的训练阶段，每个阶段包含1000步，以逐步将上下文窗口从4K扩展到32K，然后再扩展到128K。YaRN的配置与DeepSeek - V2中使用的配置一致，仅应用于解耦的共享键\(k^t_R\)。两个阶段的超参数保持相同，缩放因子\(s = 40\)，\(\alpha = 1\)，\(\beta = 32\)，以及缩放系数\(\sqrt{t} = 0.1 \ln s + 1\)。在第一阶段，序列长度设置为32K，批量大小为1920。在第二阶段，序列长度增加到128K，批量大小减少到480。两个阶段的学习率均设置为\(7.3×10^{-6}\)，与预训练阶段的最终学习率相匹配。通过这两阶段的扩展训练，DeepSeek - V3能够处理长度高达128K的输入，同时保持强大的性能。图8表明，经过监督微调后，DeepSeek - V3在 “大海捞针”（Needle In A Haystack，NIAH）测试中取得了显著的性能，证明了在长达128K的上下文窗口长度内具有一致的稳健性。
## 4.4 评估
### 4.4.1 评估基准
DeepSeek - V3的基础模型在以英语和中文为主的多语言语料库上进行预训练，因此我们主要在一系列以英语和中文为主的基准测试以及一个多语言基准测试上评估其性能。我们的评估基于集成在HAI - LLM框架中的内部评估框架。所考虑的基准测试分类如下，其中带下划线的基准测试为中文，双下划线的基准测试为多语言：
 - **多学科多项选择数据集**：包括MMLU（Hendrycks等人，2020）、MMLU - Redux（Gema等人，2024）、MMLU - Pro（Wang等人，2024b）、MMMLU（OpenAI，2024b）、<u>C - Eval</u>（Huang等人，2023）和<u>CMMLU</u>（Li等人，2023）。
 - **语言理解与推理数据集**：包括HellaSwag（Zellers等人，2019）、PIQA（Bisk等人，2020）、ARC（Clark等人，2018）和BigBench Hard（BBH）（Suzgun等人，2022）。
 - **闭卷问答数据集**：包括TriviaQA（Joshi等人，2017）和NaturalQuestions（Kwiatkowski等人，2019）。
 - **阅读理解数据集**：包括RACE（Lai等人，2017）、DROP（Dua等人，2019）、C3（Sun等人，2019a）和CMRC（Cui等人，2019）。
 - **指代消解数据集**：包括CLUEWSC（Xu等人，2020）和WinoGrande（Sakaguchi等人，2019）。
 - **语言建模数据集**：包括Pile（Gao等人，2020）。
 - **中文理解与文化数据集**：包括<u>CCPM</u>（Li等人，2021）。
 - **数学数据集**：包括GSM8K（Cobbe等人，2021）、MATH（Hendrycks等人，2021）、MGSM（Shi等人，2023）和<u>CMath</u>（Wei等人，2023）。
 - **代码数据集**：包括HumanEval（Chen等人，2021）、LiveCodeBench - Base（0801 - 1101）（Jain等人，2024）、MBPP（Austin等人，2021）和CRUXEval（Gu等人，2024）。
 - **标准化考试**：包括AGIEval（Zhong等人，2023）。请注意，AGIEval包括英语和中文子集。

遵循我们之前的工作（DeepSeek - AI，2024b，c），对于包括HellaSwag、PIQA、WinoGrande、RACE - Middle、RACE - High、MMLU、MMLU - Redux、MMLU - Pro、MMMLU、ARC - Easy、ARC - Challenge、C - Eval、CMMLU、C3和CCPM在内的数据集，我们采用基于困惑度的评估；对于TriviaQA、NaturalQuestions、DROP、MATH、GSM8K、MGSM、HumanEval、MBPP、LiveCodeBench - Base、CRUXEval、BBH、AGIEval、CLUEWSC、CMRC和CMath，我们采用基于生成的评估。此外，对于Pile - test，我们执行基于语言建模的评估，并使用每字节比特数（Bits - Per - Byte，BPB）作为指标，以确保在使用不同分词器的模型之间进行公平比较。
### 4.4.2 评估结果
在表3中，我们将DeepSeek - V3的基础模型与当前最先进的开源基础模型进行比较，包括DeepSeek - V2 - Base（DeepSeek - AI，2024c）（我们之前发布的模型）、Qwen2.5 72B Base（Qwen，2024b）和LLaMA - 3.1 405B Base（AI@Meta，2024b）。我们使用内部评估框架对所有这些模型进行评估，并确保它们具有相同的评估设置。请注意，由于过去几个月我们评估框架的变化，DeepSeek - V2 - Base的性能与我们之前报告的结果略有差异。总体而言，DeepSeek - V3 - Base全面超越DeepSeek - V2 - Base和Qwen2.5 72B Base，并在大多数基准测试中超过LLaMA - 3.1 405B Base，基本上成为最强的开源模型。

从更详细的角度来看，我们分别将DeepSeek - V3 - Base与其他开源基础模型进行比较。（1）与DeepSeek - V2 - Base相比，由于我们在模型架构上的改进、模型规模和训练词元的增加以及数据质量的提升，DeepSeek - V3 - Base如预期般取得了显著更好的性能。（2）与当前最先进的中文开源模型Qwen2.5 72B Base相比，DeepSeek - V3 - Base仅用一半的激活参数，也展现出显著优势，尤其是在英语、多语言、代码和数学基准测试上。至于中文基准测试，除了中文多学科多项选择任务<u>CMMLU</u>外，DeepSeek - V3 - Base的表现也优于Qwen2.5 72B。（3）与拥有11倍激活参数的最大开源模型LLaMA - 3.1 405B Base相比，DeepSeek - V3 - Base在多语言、代码和数学基准测试上也表现得更好。在英语和中文语言基准测试上，DeepSeek - V3 - Base表现出具有竞争力或更优的性能，在BBH、MMLU系列、DROP、<u>C - Eval</u>、<u>CMMLU</u>和<u>CCPM</u>上尤其出色。

由于我们高效的架构和全面的工程优化，DeepSeek - V3实现了极高的训练效率。在我们的训练框架和基础设施下，在每一万亿词元上训练DeepSeek - V3仅需18万个H800 GPU小时，这比训练720亿或4050亿参数的密集模型成本低得多。

![](https://borninfreedom.github.io/images/2025/01/ds/t4.png)

![](https://borninfreedom.github.io/images/2025/01/ds/t5.png)
表5 | 无辅助损失平衡策略的消融结果。与纯基于辅助损失的方法相比，无辅助损失策略在大多数评估基准上始终能实现更好的模型性能。 

![](https://borninfreedom.github.io/images/2025/01/ds/9.png)
图9 | 在Pile测试集中，无辅助损失模型和基于辅助损失模型在三个领域上的专家负载情况。无辅助损失模型比基于辅助损失的模型呈现出更强的专家专业化模式。相对专家负载指的是实际专家负载与理论均衡专家负载之间的比率。由于篇幅限制，我们仅以两层的结果为例进行展示，所有层的结果见附录C。 

## 4.5 讨论
### 4.5.1 多词元预测的消融研究
在表4中，我们展示了MTP策略的消融结果。具体来说，我们在不同规模的两个基线模型上验证MTP策略。在小规模上，我们在1.33T词元上训练一个总参数为157亿的基线MoE模型。在大规模上，我们在540亿词元上训练一个总参数为2287亿的基线MoE模型。在此基础上，保持训练数据和其他架构不变，我们在它们之上附加一个1深度的MTP模块，并使用MTP策略训练两个模型进行比较。请注意，在推理时，我们直接丢弃MTP模块，因此比较的模型推理成本完全相同。从表中可以看出，MTP策略在大多数评估基准上持续提升了模型性能。
### 4.5.2 无辅助损失平衡策略的消融研究
在表5中，我们展示了无辅助损失平衡策略的消融结果。我们在不同规模的两个基线模型上验证该策略。在小规模上，我们在1.33T词元上训练一个总参数为157亿的基线MoE模型。在大规模上，我们在578亿词元上训练一个总参数为2287亿的基线MoE模型。这两个基线模型都纯粹使用辅助损失来促进负载均衡，并使用带有前K亲和度归一化的sigmoid门控函数。它们控制辅助损失强度的超参数分别与DeepSeek - V2 - Lite和DeepSeek - V2相同。在这两个基线模型的基础上，保持训练数据和其他架构不变，我们去除所有辅助损失并引入无辅助损失平衡策略进行比较。从表中可以看出，无辅助损失策略在大多数评估基准上始终能取得更好的模型性能。
### 4.5.3 批次级负载均衡与序列级负载均衡
无辅助损失平衡和序列级辅助损失的关键区别在于它们的平衡范围：批次级与序列级。与序列级辅助损失相比，批次级平衡施加了更灵活的约束，因为它不强制每个序列在域内保持平衡。这种灵活性使专家能够更好地在不同领域实现专业化。为了验证这一点，我们记录并分析了基于160亿参数辅助损失的基线模型和160亿参数无辅助损失模型在Pile测试集不同领域上的专家负载。如图9所示，我们观察到无辅助损失模型如预期般展现出更强的专家专业化模式。

为了进一步研究这种灵活性与模型性能优势之间的相关性，我们额外设计并验证了一种批次级辅助损失，它鼓励每个训练批次而非每个序列上的负载均衡。实验结果表明，当实现相似程度的批次级负载均衡时，批次级辅助损失也能达到与无辅助损失方法相似的模型性能。具体来说，在我们对10亿参数MoE模型的实验中，验证损失分别为：2.258（使用序列级辅助损失）、2.253（使用无辅助损失方法）和2.253（使用批次级辅助损失）。在30亿参数MoE模型上我们也观察到类似结果：使用序列级辅助损失的模型验证损失为2.085，使用无辅助损失方法或批次级辅助损失的模型验证损失均为2.080。

此外，尽管批次级负载均衡方法表现出一致的性能优势，但它们在效率方面也面临两个潜在挑战：（1）某些序列或小批次内的负载不平衡，以及（2）推理过程中由域转移引起的负载不平衡。第一个挑战可以通过我们使用大规模专家并行和数据并行的训练框架自然解决，这保证了每个微批次的规模较大。对于第二个挑战，我们也设计并实现了一个带有冗余专家部署的高效推理框架，如3.4节所述，以克服这一问题。 

# 5. 训练后处理
## 5.1 监督微调
我们精心整理了指令调整数据集，包含150万个跨越多个领域的实例，每个领域根据其特定需求采用不同的数据创建方法。
- **推理数据**：对于与推理相关的数据集，包括数学、代码竞赛问题和逻辑谜题等，我们利用内部的DeepSeek - R1模型生成数据。具体而言，虽然R1生成的数据准确性较高，但存在过度思考、格式不佳和长度过长等问题。我们的目标是平衡R1生成的推理数据的高准确性与常规格式推理数据的清晰简洁性。

为确立方法，我们首先针对特定领域（如代码、数学或一般推理），使用监督微调（SFT）和强化学习（RL）相结合的训练流程开发一个专家模型。这个专家模型作为最终模型的数据生成器。训练过程为每个实例生成两种不同类型的SFT样本：第一种以<问题, 原始回答>的格式将问题与其原始回答配对；第二种则以<系统提示, 问题, R1回答>的格式，在问题和R1回答的基础上加入系统提示。

系统提示经过精心设计，包含引导模型生成富有反思和验证机制的回答的指令。在强化学习阶段，即使没有明确的系统提示，模型也会利用高温采样生成融合了R1生成数据和原始数据模式的回答。经过数百步强化学习后，中间的强化学习模型学会融入R1模式，从而从策略上提升整体性能。

在完成强化学习训练阶段后，我们采用拒绝采样为最终模型筛选高质量的SFT数据，其中专家模型作为数据生成源。这种方法确保最终训练数据保留DeepSeek - R1的优势，同时生成简洁有效的回答。
- **非推理数据**：对于非推理数据，如创意写作、角色扮演和简单问答，我们利用DeepSeek - V2.5生成回答，并邀请人工标注员验证数据的准确性和正确性。
- **SFT设置**：我们使用SFT数据集对DeepSeek - V3基础模型进行两个epoch的微调，采用余弦退火学习率调度，从5×10^{-6}开始，逐渐降至1×10^{-6}。在训练过程中，每个单一序列由多个样本打包而成。不过，我们采用样本掩码策略，确保这些示例相互独立且不可见。
## 5.2 强化学习
### 5.2.1 奖励模型
在强化学习过程中，我们采用基于规则的奖励模型（RM）和基于模型的奖励模型。
- **基于规则的RM**：对于可以使用特定规则验证的问题，我们采用基于规则的奖励系统来确定反馈。例如，某些数学问题有确定的结果，我们要求模型以指定格式（如放在方框内）给出最终答案，以便我们应用规则验证其正确性。同样，对于力扣（LeetCode）问题，我们可以利用编译器根据测试用例生成反馈。只要有可能，我们就利用基于规则的验证，确保更高的可靠性，因为这种方法不易被操纵或利用。
- **基于模型的RM**：对于具有自由格式真实答案的问题，我们依靠奖励模型来确定回答是否符合预期的真实答案。相反，对于没有明确真实答案的问题，如创意写作相关问题，奖励模型的任务是根据问题和相应答案作为输入提供反馈。奖励模型从DeepSeek - V3的SFT检查点进行训练。为提高其可靠性，我们构建偏好数据，这些数据不仅提供最终奖励，还包括得出奖励的思维链。这种方法有助于降低特定任务中奖励被破解的风险。
### 5.2.2 组相对策略优化（Group Relative Policy Optimization，GRPO算法）

![](https://borninfreedom.github.io/images/2025/01/ds/tmp7.png)
![](https://borninfreedom.github.io/images/2025/01/ds/m7.png)


在强化学习过程中，我们融入了来自不同领域的提示，如编码、数学、写作、角色扮演和问答等。这种方法不仅使模型更贴合人类偏好，还提升了在基准测试中的表现，尤其是在可用监督微调（SFT）数据有限的场景中。

![](https://borninfreedom.github.io/images/2025/01/ds/t6.png)
表6 | DeepSeek - V3与其他代表性聊天模型的对比。所有模型均在输出长度限制为8K的配置下进行评估。对于样本数量少于1000的基准测试，会使用不同的温度设置多次测试，以得出可靠的最终结果。DeepSeek - V3是性能最佳的开源模型，并且与前沿闭源模型相比也展现出具有竞争力的性能。 

## 5.3 评估
### 5.3.1 评估设置
- **评估基准**：除了用于基础模型测试的基准外，我们还在以下基准上进一步评估指令模型：IFEval（周等人，2023）、FRAMES（克里希纳等人，2024）、LongBench v2（白等人，2024）、GPQA（赖因等人，2023）、SimpleQA（OpenAI，2024c）、C - SimpleQA（何等人，2024）、SWE - Bench Verified（OpenAI，2024d）、Aider 1、LiveCodeBench（贾恩等人，2024）（2024年8月至11月的问题）、Codeforces 2、中国数学奥林匹克竞赛（CNMO 2024）3 以及2024年美国数学邀请赛（AIME 2024）（美国数学协会，2024）。
- **对比基线**：我们将聊天模型与多个强大的基线模型进行全面评估对比，包括DeepSeek - V2 - 0506、DeepSeek - V2.5 - 0905、Qwen2.5 72B Instruct、LLaMA - 3.1 405B Instruct、Claude - Sonnet - 3.5 - 1022和GPT - 4o - 0513。对于DeepSeek - V2模型系列，我们选择最具代表性的变体进行比较。对于闭源模型，通过其各自的应用程序编程接口（API）进行评估。
- **详细评估配置**：对于包括MMLU、DROP、GPQA和SimpleQA在内的标准基准，我们采用来自simple - evals框架4 的评估提示。对于MMLU - Redux，在零样本设置下，我们使用Zero - Eval提示格式（林，2024）。对于其他数据集，我们遵循其原始评估协议，并使用数据集创建者提供的默认提示。对于代码和数学基准，HumanEval - Mul数据集总共包括8种主流编程语言（Python、Java、Cpp、C#、JavaScript、TypeScript、PHP和Bash）。我们使用思维链（CoT）和非思维链方法评估LiveCodeBench上的模型性能，该数据收集于2024年8月至11月。Codeforces数据集使用参赛者百分比进行衡量。SWE - Bench verified使用无代理框架（夏等人，2024）进行评估。我们使用“diff”格式评估与Aider相关的基准。对于数学评估，AIME和CNMO 2024在温度为0.7的情况下进行评估，结果取16次运行的平均值，而MATH - 500采用贪婪解码。我们允许所有模型在每个基准测试中最多输出8192个词元。
### 5.3.2 标准评估
表6展示了评估结果，表明DeepSeek - V3是性能最佳的开源模型。此外，它与GPT - 4o和Claude - 3.5 - Sonnet等前沿闭源模型相比也具有竞争力。
- **英语基准**：MMLU是一个广泛认可的基准，旨在评估大语言模型在不同知识领域和任务中的性能。DeepSeek - V3展现出具有竞争力的性能，与LLaMA - 3.1 - 405B、GPT - 4o和Claude - Sonnet 3.5等顶级模型相当，同时显著超越Qwen2.5 72B。此外，DeepSeek - V3在MMLU - Pro（一个更具挑战性的教育知识基准）中表现出色，紧随Claude - Sonnet 3.5之后。在MMLU - Redux（MMLU的改进版本，带有修正标签）上，DeepSeek - V3超越了同类模型。另外，在GPQA - Diamond（一个博士水平的评估测试平台）上，DeepSeek - V3取得了显著成绩，仅次于Claude 3.5 Sonnet，并且大幅领先其他所有竞争对手。

在DROP、LongBench v2和FRAMES等长上下文理解基准测试中，DeepSeek - V3继续展现其顶级模型的地位。在DROP的3次射击设置中，它取得了令人印象深刻的91.6的F1分数，在该类别中超越了所有其他模型。在FRAMES（一个需要在100k词元上下文上进行问答的基准）上，DeepSeek - V3紧随GPT - 4o之后，同时大幅领先其他所有模型。这表明DeepSeek - V3在处理极长上下文任务方面具有强大的能力。DeepSeek - V3的长上下文能力在LongBench v2上得到了进一步验证，该数据集在DeepSeek V3发布前几周才发布，而DeepSeek - V3在该数据集上表现最佳。在事实性知识基准SimpleQA上，DeepSeek - V3落后于GPT - 4o和Claude - Sonnet，这主要是由于其设计重点和资源分配。DeepSeek - V3将更多的训练词元用于学习中文知识，因此在C - SimpleQA上表现出色。在指令跟随基准测试中，DeepSeek - V3显著超越其前身DeepSeek - V2系列，突出了其在理解和遵循用户定义格式约束方面能力的提升。
- **代码和数学基准**：编码对于大语言模型来说是一项具有挑战性和实用性的任务，涵盖了如SWE - Bench - Verified和Aider等以工程为重点的任务，以及HumanEval和LiveCodeBench等算法任务。在工程任务中，DeepSeek - V3落后于Claude - Sonnet - 3.5 - 1022，但显著超越开源模型。开源的DeepSeek - V3有望推动编码相关工程任务的进展。通过提供其强大的功能，DeepSeek - V3可以在软件工程和算法开发等领域推动创新和改进，使开发者和研究人员能够突破开源模型在编码任务中所能达到的极限。在算法任务中，DeepSeek - V3展现出卓越的性能，在HumanEval - Mul和LiveCodeBench等基准测试中超越了所有基线模型。这一成功可归因于其先进的知识蒸馏技术，该技术有效地提升了其在以算法为重点的任务中的代码生成和问题解决能力。

在数学基准测试中，DeepSeek - V3表现卓越，显著超越基线模型，为非类似o1的模型树立了新的最先进水平。具体而言，在AIME、MATH - 500和CNMO 2024上，DeepSeek - V3的绝对分数比排名第二的Qwen2.5 72B高出约10%，对于如此具有挑战性的基准测试来说，这是一个相当大的差距。这种卓越的能力凸显了来自DeepSeek - R1的蒸馏技术的有效性，事实证明该技术对非类似o1的模型非常有益。
- **中文基准**：Qwen和DeepSeek是两个对中文和英文都有强大支持的代表性模型系列。在事实性基准测试Chinese SimpleQA上，尽管Qwen2.5训练的语料库更大，包含18T词元，比DeepSeek - V3预训练的14.8T词元多20%，但DeepSeek - V3仍比Qwen2.5 - 72B高出16.4分。

在C - Eval（一个用于中文教育知识评估的代表性基准）和CLUEWSC（中文Winograd Schema Challenge）上，DeepSeek - V3和Qwen2.5 - 72B表现出相似的性能水平，表明这两个模型在具有挑战性的中文推理和教育任务方面都经过了良好的优化。

![](https://borninfreedom.github.io/images/2025/01/ds/t7.png)
表7 | 英文开放式对话评估。对于AlpacaEval 2.0，我们使用长度受控胜率作为评估指标。 


### 5.3.3 开放式评估
除了标准基准测试外，我们还使用大语言模型作为评判者，对模型在开放式生成任务上进行评估，结果见表7。具体来说，我们遵循AlpacaEval 2.0（杜波依斯等人，2024）和Arena - Hard（李等人，2024a）的原始配置，它们利用GPT - 4 - Turbo - 1106作为评判者进行两两比较。在Arena - Hard上，DeepSeek - V3与基线GPT - 4 - 0314相比，取得了令人印象深刻的超过86%的胜率，与Claude - Sonnet - 3.5 - 1022等顶级模型表现相当。这突出了DeepSeek - V3的强大能力，尤其是在处理复杂提示（包括编码和调试任务）方面。此外，DeepSeek - V3取得了突破性的里程碑，成为第一个在Arena - Hard基准测试中超过85%胜率的开源模型。这一成就显著缩小了开源模型和闭源模型之间的性能差距，为开源模型在具有挑战性的领域中所能达到的水平树立了新的标准。

同样，DeepSeek - V3在AlpacaEval 2.0上也展现出卓越的性能，超越了闭源和开源模型。这表明它在写作任务和处理简单问答场景方面具有出色的熟练度。值得注意的是，它比DeepSeek - V2.5 - 0905大幅领先20%，凸显了在处理简单任务方面的显著改进，并展示了其改进的有效性。
![](https://borninfreedom.github.io/images/2025/01/ds/t8.png)
![](https://borninfreedom.github.io/images/2025/01/ds/t9.png)

### 5.3.4 DeepSeek - V3作为生成式奖励模型
我们将DeepSeek - V3的评判能力与最先进的模型（即GPT - 4o和Claude - 3.5）进行比较。表8展示了这些模型在RewardBench（兰伯特等人，2024）中的性能。DeepSeek - V3的性能与GPT - 4o - 0806和Claude - 3.5 - Sonnet - 1022的最佳版本相当，同时超越了其他版本。此外，DeepSeek - V3的评判能力还可以通过投票技术得到提升。因此，我们采用DeepSeek - V3结合投票的方式，为开放式问题提供自我反馈，从而提高对齐过程的有效性和稳健性。
## 5.4 讨论
### 5.4.1 来自DeepSeek - R1的知识蒸馏
我们基于DeepSeek - V2.5对来自DeepSeek - R1的知识蒸馏贡献进行消融实验。基线模型在短思维链（CoT）数据上进行训练，而其竞争模型使用上述专家检查点生成的数据。

表9展示了蒸馏数据的有效性，在LiveCodeBench和MATH - 500基准测试中都显示出显著的改进。我们的实验揭示了一个有趣的权衡：知识蒸馏带来了更好的性能，但也大幅增加了平均响应长度。为了在模型准确性和计算效率之间保持平衡，我们为DeepSeek - V3在知识蒸馏中精心选择了最优设置。

我们的研究表明，从推理模型进行知识蒸馏为训练后优化提供了一个有前景的方向。虽然我们目前的工作侧重于从数学和编码领域提取数据，但这种方法在更广泛的任务领域中显示出应用潜力。在这些特定领域中所展示的有效性表明，长思维链蒸馏对于提升其他需要复杂推理的认知任务中的模型性能可能具有重要价值。在不同领域进一步探索这种方法仍然是未来研究的一个重要方向。
### 5.4.2 自我奖励
奖励在强化学习中起着关键作用，引导优化过程。在通过外部工具进行验证较为直接的领域，如某些编码或数学场景中，强化学习表现出卓越的效果。然而，在更一般的场景中，通过硬编码构建反馈机制是不切实际的。在DeepSeek - V3的开发过程中，对于这些更广泛的场景，我们采用了可控生成式人工智能（constitutional AI）方法（白等人，2022），利用DeepSeek - V3自身的投票评估结果作为反馈源。这种方法产生了显著的对齐效果，显著提升了DeepSeek - V3在主观评估中的性能。通过整合额外的可控输入，DeepSeek - V3可以朝着可控方向进行优化。我们认为，这种将补充信息与大语言模型相结合作为反馈源的范式至关重要。大语言模型作为一种通用处理器，能够将来自不同场景的非结构化信息转化为奖励，最终促进大语言模型的自我提升。除了自我奖励，我们还致力于发现其他通用且可扩展的奖励方法，以持续提升模型在一般场景中的能力。
### 5.4.3 多词元预测评估
DeepSeek - V3通过多词元预测（MTP）技术预测接下来的2个词元，而不仅仅是下一个单一词元。结合推测解码框架（利维坦等人，2023；夏等人，2023），它可以显著加快模型的解码速度。一个自然的问题是额外预测词元的接受率如何。根据我们的评估，在各种生成主题中，第二个词元预测的接受率在85%到90%之间，显示出一致的可靠性。这种高接受率使DeepSeek - V3能够显著提高解码速度，达到每秒1.8倍的词元生成量（TPS，Tokens Per Second）。
# 6. 结论、局限性与未来方向
在本文中，我们介绍了DeepSeek - V3，这是一个大型混合专家（MoE）语言模型，总共有6710亿个参数，激活参数为370亿个，在14.8T词元上进行训练。除了MLA和DeepSeekMoE架构外，它还首创了一种无辅助损失的负载均衡策略，并设置了多词元预测训练目标以提升性能。由于有FP8训练的支持和精细的工程优化，DeepSeek - V3的训练具有成本效益。训练后处理也成功地从DeepSeek - R1系列模型中提炼出推理能力。综合评估表明，DeepSeek - V3已成为目前最强大的开源模型，性能可与GPT - 4o和Claude - 3.5 - Sonnet等领先的闭源模型相媲美。尽管它性能强大，但仍保持了经济的训练成本。其完整训练，包括预训练、上下文长度扩展和训练后处理，仅需要278.8万个H800 GPU小时。

尽管DeepSeek - V3性能强大且具有成本效益，但我们也认识到它存在一些局限性，尤其是在部署方面。首先，为确保高效推理，DeepSeek - V3推荐的部署单元相对较大，这可能给小型团队带来负担。其次，尽管我们为DeepSeek - V3制定的部署策略已实现了比DeepSeek - V2快两倍以上的端到端生成速度，但仍有进一步提升的空间。幸运的是，随着更先进硬件的发展，这些局限性有望自然得到解决。

DeepSeek始终坚持开源模型的长期主义路线，旨在稳步迈向通用人工智能（AGI，Artificial General Intelligence）的最终目标。未来，我们计划在以下几个方向进行有策略的研究投入：
- 我们将持续研究和优化模型架构，旨在进一步提高训练和推理效率，努力实现对无限上下文长度的高效支持。此外，我们将尝试突破Transformer的架构限制，从而拓展其建模能力的边界。
- 我们将不断迭代训练数据的数量和质量，并探索纳入更多的训练信号源，目标是在更全面的维度上推动数据扩展。
- 我们将持续探索和迭代模型的深度思考能力，旨在通过扩展推理长度和深度来提升其智能和问题解决能力。
- 我们将探索更全面、多维度的模型评估方法，以防止在研究过程中出现过度优化固定基准测试集的倾向，这种倾向可能会对模型能力产生误导性印象，并影响我们的基础评估。 




# B. 低精度训练的消融研究

![](https://borninfreedom.github.io/images/2025/01/ds/10.png)
图10 | BF16和FP8训练的损失曲线对比。结果通过指数移动平均（EMA）进行平滑处理，系数为0.9。 

## B.1 FP8与BF16训练对比
我们通过在不同规模的两个基线模型上，将FP8混合精度框架与BF16训练进行对比，来验证FP8框架的有效性。在小规模上，我们在1.33万亿词元上训练一个总参数约160亿的基线混合专家（MoE）模型。在大规模上，我们在约0.9万亿词元上训练一个总参数约2300亿的基线MoE模型。
我们在图10中展示了训练曲线，结果表明，通过我们的高精度累加和细粒度量化策略，相对误差保持在0.25%以下。
## B.2 关于按块量化的讨论
尽管我们的按块（tile - wise）细粒度量化有效地减轻了由特征异常值引入的误差，但它对激活量化需要不同的分组方式，即在正向传播中为1x128，在反向传播中为128x1。对激活梯度也需要类似的处理过程。一个简单直接的策略是像对模型权重进行量化那样，对每128x128个元素进行按块量化。这样，在反向传播时只需要进行转置操作。因此，我们进行了一项实验，对与激活反向传播（Dgrad）相关的所有张量都按块进行量化。结果表明，以链式方式计算激活梯度并反向传播到浅层的Dgrad操作对精度高度敏感。具体来说，对激活梯度进行按块量化，会导致在总参数约160亿、在约3000亿词元上训练的MoE模型出现发散。我们推测，这种敏感性的产生是因为激活梯度在词元之间极不均衡，从而导致与词元相关的异常值（Xi等人，2023）。而按块量化方法无法有效处理这些异常值。
# C. 160亿参数基于辅助损失和无辅助损失模型的专家专业化模式
我们记录了160亿参数基于辅助损失的基线模型和无辅助损失模型在Pile测试集上的专家负载情况。如图10所示，无辅助损失模型在所有层上往往具有更强的专家专业化。
![](https://borninfreedom.github.io/images/2025/01/ds/10_1.png)
![](https://borninfreedom.github.io/images/2025/01/ds/10_2.png)
![](https://borninfreedom.github.io/images/2025/01/ds/10_3.png)
![](https://borninfreedom.github.io/images/2025/01/ds/10_4.png)
![](https://borninfreedom.github.io/images/2025/01/ds/10_5.png)
图10 | 在Pile测试集中，无辅助损失模型和基于辅助损失模型在三个领域上的专家负载情况。无辅助损失模型比基于辅助损失的模型呈现出更强的专家专业化模式。相对专家负载指的是实际专家负载与理论均衡专家负载之间的比率。 

